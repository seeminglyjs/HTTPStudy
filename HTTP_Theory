http는 HTML에서 확인할 수 있는 request 와 response를 나타낸다.


////2020  - 10 - 20

1.1 ~ 1.2
웹 서버는 http 프로토콜로 의사소통 하기 때문에 http 서버라고도 불린다.
클라이언트가 서버에 http를 요청하고 이에 대하여 서버가 http로 응답하는 과정을 거친다.

1.3
어떤 종류의 컨텐츠 소스도 리소스가 될 수 있다

1.31 media type
http 는 웹에서 전송되는 객체 각각에 신중하게 mime 타입이라는 데이터 포맥 라벨을 붙이다.
mime는 / 사선으로 구분되면 앞에는 주타임 뒤에는 부타입을 나타낸다.ex) Content-type : image/jpeg

1.32 uri
uri(uniform resource identifier) : 정보리소스를 고유하게 식별하고 위치를 지정할 수있다. 
클라이언트가 선택하는 관심있는 리소스

1.33 url
url(uniform resource locator) : 리소스 식별자의 가장 흔한 형태다.
이는 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.
구서 요소로는 스킴(http://) + 주소 + 웹서버의 리소스

※ url 과 uri 가 같은 의미로 사용되기도 한다.

1.34 urn

1.4 트랜잭션

1.41 메서드
http 는 여러 종류의 method가 있는데 그 중에서 가장 많이 사용되는 것
get : 서버에서 클라ㅣ언트로 지정한 리소스를 보내라
put : 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라
delete : 지정한 리소스를 서버에서 삭제하라
post : 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라.
head : 지정한 리소스에 대한 응답에서 http의 헤더 부분만 보내라.

1.42 상태코드
http 상태코드 200(좋다), 302(다시 보내라), 404(오류)

http이 메세지 구성은 시작줄 / 헤더 / 본문 으로 이루어져 있다.
이 중 헤더는  :쌍점으로 구분되며, 빈줄로 끝난다.
http / 1.0 200 OK (시작줄)
Content-type : text/plain(헤더)
Content-length 19

Hello World!(본문)

1.43 웹페이즌 여러 객체로 이루어져 있다.

1.5 메시지
메시지는 3부분으로 나누어진다.
시작줄 / 헤더 / 본문

1.51 간단한 메시지의 예


//////// p 13 까지 공부

////2020  - 10 - 21
  
  1.6 tcp 커넥션
  
  1.61 tcp /ip
  TCP/IP는 TCP/IP가 층을 이루는 패킷교환 네트워크 프로토콜의 집합이다.
  일단 TCP 커넥션이 맺어지면 클라이언트와 서버 컴퓨터간에 교환되는
  메세지가 없어지거나 손상되거나 순서가 뒤바뀌어 수신되는 일은 결코 없다.
  IP < TCP < HTTP(상위계층)
  
  1.62 접속 ip 주소 그리고 포트번호
  HTTP의 서버의 IP주소와 포트번호는 URL을 이용해 손쉽게 알아넬 수 있다.
   
  호스트 명은 IP주소에 대한 이해하기 쉬운 형태의 별명인데, 호스트 명은
  도메인 이름 서비스 DNS 라 불리는 장치를 통해 쉽게 IP로 변환될  수 있다.
  
  1.63 텔넷을 이용한 실제 사례
  텔넷 유틸리티는 당신의 키보드를 목적지의 TCP포토로 연결해주고 출력 TCP포트를
  당신의 화면에 연결해 준다. 텔넷은 원격 터미널 세션을 위해 흔히 사용되지만
  HTTP 서버를 포함한 일반적인 tcp 서버에 연결하기 위해 사용될 수도 있다.
  
  ////웹의 구성요소 //////
  
  프락시 : 클라이언트와 서버사이에 위치하여, 클라이언트의 모든 HTTP요청을 받아
  서버에 전달한다. 주로 보안을 위해 사용되며, 요청과 응답을 필터링한다.
  
  캐시: 웹캐시와 캐시 프락시는 자신을 거쳐가는 문서들 중 자주 찾는 것의 사본을 
  저장 해 두는, 특별한 종류의 HTTP 프락시 서버이다.
  
  게이트웨이: HTTP트래픽을 다른 프로토콜로 변환하기 위해 사용한다.
  
  터널: 두 커넥션 사이에서 날 데이터를 열어보지 않고 그대로 전달해주는
  HTTP 어플리케이션이다.

////////////////////2장 URL과 리소스//////////////////////////

  URL은 부라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며, URL을 이용해 
  사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며, 공유할 수 있다.
  대부분의 URL은 스킴://서버위치/경로 로 구성되어 있다.
  
  URL 스킬의 문법은 일반적으로 9개로 나누어지며, 중요한 세가지는
  컴포넌트는 스킴, 호스트, 경로 이다.
  
  <스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프레그먼트>
  자세한 내용은 p 31 쪽~~ 참고
  
  질의 문자열은 보통 리소스에 해당 자원이 있는지에 대하여 확인을 하기 위해 사용한다.
  제외된 특정 문자를 제외하고 편의상 &을 이용해 이름 = 값 쌍 형식의 질의 문자열을 많이 사용한다.
  
  프래그먼트는 리소스안에 특정 절을 가리킬 수 있는 컨포넌트로써 # 뒤에 해당 프레그먼트를 넣으면
  웹사이트상에 스크롤이 해당 리소스로 이동하게 된다.

  p 35 까지 공부
  
////2020  - 10 - 22

  2.31
  url은 상대 url과 절대 url 두가지로 나늰다. 절대 url은 리소스에 접근하는데 필요한 모든 정보를 가지고 있다.
  그와달리 상대 url은 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는 기저(base)라고 하는 다른 url 을 사용해야 한다.
  상대 url은 url을 짧게 표기하는 방식이다.
  상대 url은 프래그먼트이거나 url 일부다. url을 처리하는 브라우저 같은 애플리케이션은 상대 url과 절대 url간에
  상호 변환을 할 수 있어야 한다.
  
  url의 변환 괒어은 p 38 ~ 39 쪽을 참고하자!
  
  2.32
  어떤 부라우저들은 url을 입력한 다음이나 입력하고 있는 동안에 자동으로 url을 확장한다.
  이 확장 기능은 두가지로 나누어 진다.
  1. 호스트명 확장 : 이 기능을 지원하는 브라우저는 단순한 휴리스틱스만을 사용해서 입력한 호스트명을
  전체 호스트 명으로 확장할 수 있다.  
  2. 히스토리 확장: 사용자가 url을 입력하는 시간을 줄이고자, 브라우저가 사용하는 또 다른 기술은 과거에
  사용자가 방문했던 url의 기록을 저장해 놓은 것이다. (cookie)를 말하는 듯 싶다...
  
  2.4 안전하지 않은 문자.
  url은 잘 호환되도록 설계되었다. 안전한 전송이란 정보가 유실될 위험 없이 url을 전송할 수 있다는 것을 의미한다.
  하지만 url은 더 완벽해져야 했다. url 설계자는 사람들이 url에 이진 데이터나 일반적으로 안전한 알파벳 외의 문자도
  포함하려고 할 때가 있다는 것을 알게 되었다. 그래서 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한
  문자로 인코딩할 수 있게 하였다.
  
  2.41
  컴퓨터 시스템의 기본문자는 영어중심으로 설정되어 있다. (US-ASCII) 때문에 사용가능한 문자들이 한정적
  대안으로 이스케이프 기능을 통해 US-ASCII에서 사용이 금지된 문자들도 특정문자나
  데이터를 인코딩 할 수 있게 함으로써 이동성과 완성도를 높였다.
  
  2.42 인코딩 체계
  인코딩은 안전하지 않은 문자를 퍼센티지 기호(%)로 시작해 ASCII 코드로 표현되는 두 개의 16 진수 숫자로 이루어진
  이스케이프 문자로 바꾼다.
  P 42 쪽을 참고하자.
  
  2.43 문자제한
  몇몇 문자는 url 내에서 특별한 의미로 예약이 되어 있다.
  어떤 문자는 US-ASCII의 출력 가능한 문자 집합에 포함되어 있지 않다.
  그리고 어떤 문자는 몇몇 인터넷 게이트웨이와 프로토콜에서 혼동되는 것으로 알려져 있어 사용이 꺼려졌다.
  구체적인 제한 문자들은 P 42 쪽을 참고하자.
  
  2.44
  
  2.5 스킴의 바다
  
  HTTP ==  http://<호스트>:<포트>/<경로>?<질의>#<프레그먼트>
  기본포트 : 80
  
  HTTPS == http://<호스트>:<포트>/<경로>?<질의>#<프레그먼트>
  기본포트 : 443
  기본적인 구성은  http와 같지만 넷스케이프에서 개발한 보안 소켓 계층 SSL을 사용한다는 것이다.
  
  나머지 MAILTO / FTP / RTSP,RTSPU / FILE / NEWS / TELNET 는 P 45쪽을 참고하자.
  
  2.6 ~ 2.7
  P 46 ~ 47 기타 참조 내용들
  


////2020  - 10 - 23

제 3장 http 메시지

  3.1 메시지의 흐름  
  HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.
  
  3.11 메시지는 원 서버 방향을 인바운드로 햐여 송신된다. 
  메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은
  아웃바운드로 이동하는 것이다.
  
  3.12 다운스트림으로 흐르는 메시지
  HTTP 메시지는 강물과 같이 흐르며, 요청메시지냐 응답 메시지냐에 관계없이 모든 메시지는
  다운스트림으로 흐른다. (위에서 아래로 → 보내는 쪽이 위 받는 쪽이 아래라는 의미)
  
  3.2 메세지의 각 부분
  메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.
  시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다.
  시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.
  이 줄바꿈 문자열을 CRLF라고 쓴다.
  
  3.21메시지 문법
  모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.
  
  요청 메시지 형식: <메세지> <요청URL> <버전>
                  <헤더>
                  
                  <엔티티 분문>
                  
  응답 메시지 형식: <버전> <상태 코드> <사유 구절>
                  <헤더>
                  
                  <엔티티 분문>
 
 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
 상태코드 : 요청 중에 무엇이 일어났는지 설명하는 세자리의 숫자다.
 사유 구절 : 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
 
 3.22 시작줄
 모든 HTTP 메시지는 시작줄로 시작한다.
 요청줄: 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
 응답줄: 숭행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
 
 메서드: GET/HEAD/POST/PUT/TRACE/OPTIONS/DELETE
 자세한 내용은 P55쪽을 참조하자.
 
 상태코드: 클라이언트에게 무엇이 일어났는지 말해준다.
 100 - 199 정보
 200 - 299 성공
 300 - 399 리다이렉션
 400 - 499 클라이언트 에러
 500 - 599 서버 에러
 
 200 OK  요청한 모든 데이터는 응답 본문에 들어있다.
 401 UNAUTHORIZED 사용자 이름과 비밀번호를 입력해야 한다.
 404 NOT FOUND 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다.
 
 사유구절: 상태 코드에 대한 글로 설명을 제공한다.
 버전 번호: HTPP/X.Y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
  버전 번호는 분수로 다루어 지지 않음에 주의하라 3.22 가 3.3보다 큰 수이다.
  이는 버전의 각 숫자는 분리된 숫자로 다루어지기 때문이다.
 
 3.23 헤더
 HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적으로
 이름/값 쌍의 목록이다.
 P58~59 참조
 
 헤더를 여러 줄로 나누기: 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭문자가 와야 한다.
 
 3.24엔티티본문
 
 3.25 버전 0.9 메시지
 
 3.3 메서드
 
 3.31 안전한 메서드(SAFE METHOD)
 GET / HEAD 메서드는 안전하다고 볼 수 있는데 이는 메서드를 사용하는
 HTTP의 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
 안전 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은
 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP애플리케이션을 만들 수 있도록 하는 것이다.
 EX) 송금이 된다. 등의 경고 메시지가 나타나게 하는 것
 
 3.32GET
 가장 흔희 쓰이는 메서드 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.
 
 3.33HEAD
 GET처럼 행동하지만 서버는 응답으로 헤더만을 돌려준다.
 P62참조
 
 3.34PUT
 PUT을 이용해 웹페이지를 만들고 웹서버에 직접 계시할 수도 있다.
 PUT메서드의 의미는 서버가 요청의 본문을 가지고 요청URL의 이름대로 새 문서를
 만들거나, 이미 URL이 존재한다면, 본문을 사용해서 교체하는 것이다.
 
 3.35POST
 POST 메서드는 서버에 입력데이터를 전송하기 위해 설계되었다. 
 ※POST는 서버에 데이터를 보내기 위해 사용되며,
 ※PUT는 서버에 잇는 리소스에 데이터를 입력하기 위해 사용한다.
 
 3.36TRACE
 TRACE메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
 TRACE 요청은 목적지 서버에서 LOOPBACK 진단을 시작한다.
 
 3.37OPTIONS
 OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
 
 3.38DELETE
 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 이는
 HTTP명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.
 
 3.39 확장 메서드
 P66참조
 
 3.4 상태 코드 
 3.41 ~ 3.45
 P67 ~76 참조
 
 3.5 헤더
 헤더는 일반헤더/요청헤더/응답헤더/엔티티헤더/확장헤더/로 나누어진다.(보통)
 
 3.51 일반헤더
 메시지의 아주 기본적인 정보를 제공한다.
 
 3.52요청헤더
 요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나
 클라이언트의 선호나 능력에 대한 정보를 준다.
 P79참조
 ACCEPT 관련 헤더
 P79참조
 조건부 요청 헤더 / 요청 보안 헤더
 P80참조
 
/////////// P80 까지 공부함
 
 

////2020  - 10 - 24

프락시 요청 헤더
p.81참조

3.53 응답 헤더
응답 메시지는 그들만의 헤더를 갖는다. 응답 헤더는 클라이언트에게 부가 정보를 제공한다.
응답에 대한 특별한 설명도 제공할 수 있다.

협상 헤더 / 응답 보안 헤더 

3.54 엔터티 헤더
콘텐츠 헤더 / 엔터티 캐싱 헤더
p.83 참조

////////4장 커넥션 관리 ////////

4.1 TCP 커넥션
전세계 모든 HTTP 통신은, 패킷 교환 네트워크 프로토콜들의 계층화된 집합인
TCP/IP를 통해 이루어진다.
일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은
손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

4.11 신뢰할 수 있는 데이터 통로 TCP

4.12 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
TCP 는 IP 패킷 이라고 불리는 작은 조각을 통해 데이터를 전송한다.
HTTP 는  IP / TCP / HTTP 로 구성된 프로토콜 스택에서 가장 최상위 계층이다.
HTTP에 보안 기능을 더한 HTTPS 는 TLS 혹은  SSL 이라 불리기도 하며,
HTTP TCP 사이에 있는 암호화 계층이다.

4.13 TCP 커넥션 유지하기
IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 어플리케이션으로 연결된다.
TCP 커넥션은 네 가지 값으로 식별한다.
<발신지 IP 주소, 발신지 포트, 수신지IP주소, 수신지 포트>
어떤 커넥션들은 같은 목적지 포트 번호를 가리킬 수도 있고, 같은 발신지 IP 주소를 
가르키는 커넥션들도 존재할 수 있지만 네 가지 커넥션 구성요소를 모두 똑같이
가르키고 있는 커넥션을 있을 수 없다.

4.14 TCP 소켓 프로그래밍
P.90 참조
소캣 API를 사용하면  TCP 종단 데이터 구조를 생성하고,원격 서버의 TCP 종단에
그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

4.2 TCP의 성능에 대한 고려
P 91 ~ P 98 참조

4.3 HTTP 커넥션 관리

4.31 흔히 잘못 이해하는 CONNECTION 헤더
CONNECTION 헤더는 토큰이 전달되는 3가지 방법이있다.(혼동되는)
HTTP 헤더 필드명은 이 커넥션에만 해당되는 헤더들을 나열한다.
임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미한다.
CLOSE 값은 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.

CONNECTION 헤더는 홉별 헤더명을 기술하는데, 이를 헤더 보호화기라고 한다.
HOP 은 각 서버를 의미하며, 홉별은 특정 두 서버 간에만 영향을 미치고 다른 서버 간에는
영향을 미치지 않음을 의미한다.

4.32 순차적인 트랜잭션 처리에 의한 지연
병렬 커넥션 / 지속 커넥션 / 파이프라인 커넥션 / 다중 커넥션

4.4병렬 커넥션
HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을
병렬로 처리할 수 있게 한다.

4.41 병렬 커넥션은 페이지를 더 빠르게 내려받는다.
각 커넥션의 지연시간을 겹치게 하면 총 지연 시간을 줄일 수 있고,
클라이언트의 인터넷 대역폭을 한 개의 커넥션의 다 써버리는 것이 아니라면
나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.

4.42 병렬 커넥션이 항상 더 빠르지는 않다.
네트워크의 대역폭이 좁을 때 대부분 시간을 데이터를 전송하는데 만 쓴다.
브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은수 대부분 6 ~8개의
병력 커넥션만 허용한다.

4.43 병력 커넥션은 더 빠르게 느껴질 수 있다.
화면에 여러 개의 객체를 동시에 보이면서 내려받고 있는 상황을 볼 수 있기
때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 것이다.

///P 103 까지 


////2020  - 10 - 26

  4.5 지속 커넥션
  서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해서
  그 서버에 또 요청하게 되는데, 이 속성을 사이트 지역성(STIE LOCALITY)라 부른다.
  처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 한다.
  비지속 커넥션은 각 처리가 끝날 떄마다 커넥션을 끊지만, 지속 커넥션은 클라이언트나 서버가 커넥션을
  끊기 전까지는 트랜잭션 간에도 커넥션을 유지한다.
  
  4.51 지속커넥션 VS 병렬 커넥션
  병렬 커넥션의 단점 
  1. 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
  2. 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
  3. 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.
  
  지속 커넥션은 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고, 튜닝된 커넥션을
  유지하며, 커넥션의 수를 줄여준다. 하지만 지속 커넥션을 잘못 관리할 경우, 계속
  연결된 상태로 있는 수많은 커넥션이 쌓이게 될 것이다.
  이는 로컬 리소스 그리고 원격의 클라이언트와 서버의 리소스에 불필요한 소모를 발생시킨다.
  
  지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효율적이다.
  지속 커넥션 타입은 HTTP/1.0+ 의 KEEP-ALIIVE  // HTTP/1.1의 지속 커넥션이있다.
  
  4.52 HTTP/1.0+의 KEEP-ALIVE 커넥션
  KEEP-ALIVE 커넥션의 성능상의 장점은 N개의 HTTP 트랜잭션에
  대하여, 연속적으로 N개의 커넥션을 생성하여 처리하는 방식으로
  커넥션을 맺고 끊는 데 필요한 작업이 없어서 시간이 단축되었다.
  또한 TCP 느린 시작이 일어나지 않기 때문에 요청 및 응답 시간이 줄어든다.

  4.53 KEEP-ALIVE 동작
  HTTP/1.0 KEEP-ALIVE 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서
  요청에 Connection:Keep-Alive 헤더를 포함시킨다. 이 요청을 받은 서버는
  그 다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를
  포함시켜 응답한다. Connection:Keep-Alive헤더가 없으면, 클라이언트는
  서버가 keep-alive를 지원하지 않으며, 응답 메시지가 전송되고 나면 서버 커넥션을
  끊을 것이라 추정한다.
  
  4.54 keep-alive 옵션
  p106 ~107 참고
  
  4.55 keep-alive 커넥션 제한과 규칙
  p107~108 참고
  
  4.56 keep-alive와 멍청한dumb 프락시
  Connection 헤더의 무조건 전달 / 프락시와 홉별 헤더
  p108 ~ p110 참고
  
  4.57 Proxy-Connection 살펴보기
  Proxy-Connection은 클라이언트의 요청이 중개서버를
  통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 해결한다.
  
  홉별 헤더들은 한 개의 특정 커넥션에서 쓰이고 그 이후에
  는 전달하면 안된다. 홉별 헤더를 전달받은 서버가 그 헤더를
  자신과 프락시 간의 커넥션에 대한 것으로 오해하면서 문제가 생긴다.
  
  넷스케이프는 멍청한 프락시 문제를 해결하기 위해 브라우저에서 일반적으로
  전달하는 Connection 헤더 대신에 비표준인 Proxy - Connection 확장 헤더를 프락시에게 전달한다.
  
  4.58 HTTP/1.1의 지속 커넥션
  HTTP/1.1의 지속 커넥션은 기본으로 활성화 되어 있어 별도 설정을 하지 않는한,
  모든 커넥션을 지속 커넥션으로 취급한다.
  HTTP/ 1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊을려면,
  Connection:close 헤더를 명시해야 한다.
  HTTP/1.1 클라이언트는 응답에 Connection:close 헤더가 없으면 응답 후에도
  HTTP/1.1 커넥션을 계속 유지하자는 것으로 추정한다.
  하지만 클라이언트와 서버는 언제든지 커넥션을 끊을 수 있다.
  Connection: close를 보내지 않는 것이 서버가 커넥션을 영원히 유지하겠다는 의미는 아니다.
  
  4.59 지속 커넥션의 제한과 규칙
  p113~114 참고
  
  4.6 파이프라인 커넥션
  HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있다.
  이는 keep-alive 커넥션의 성능을 더욱 높여준다.
  p114 참고
  
  4.7 커넥션 끊기에 대한 미스터리
  
  4.71 마음대로 커넥션 끊기
  
  4.72 content -Length와 Truncation
  각 HTTP 응답은 분문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.
  일부 오래된 HTTP 서버는 자신의 커넥션을 끊으면 데이터 전송이 끝났음을 의미한다.
  
  4.73 커넥션 끊기의 허용, 재시도 멱등성
  p116 참고
  
  4.74 우아한 커넥션 끊기
  전체 끊기와 절반 끊기 / TCP 끊기와 리셋에러 / 우아한 커넥션 끊기
  p117~ p119 참고
  
  4.8 추가 정보
  p120~122
  
  ////////////////////////////2부 HTTP 아키 텍처/////////////////////////////////////
  
  ///////5장 웹 서버
  
  5.1 다채로운 웹 서버
  웹 서버 라는 용어는 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비 양쪽 모두를 가르킨다.
  
  5.11 웹 서버 구현
  웹 서버는 http 프로토콜을 구현하고 웹 리소스를 관히하고, 웹 서버 관리 기능을 제공한다.
  다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치하고 실행할 수 있다.
  
  5.12 다목적 소프트웨어 웹서버
  이는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
  
  5.13 임베디드 웹 서버
  임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버이다.
  
  /////////////////p 127 까지


////2020  - 10 - 27

  5.2 간단한 펄 웹 서버
  http/1.1 의 기능들을 지원하려면, 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링 등
  그 외 성능을 위한 각종 기능들이 필요하다.
  
  5.3 진짜 웹 서버가 하는 일
  1. 커넥션을 맺는다. 
  2. 요청을 받는다.
  3. 요청을 처리한다.
  4. 리소스에 접근한다.
  5. 응답을 만든다.
  6. 응답을 보낸다.
  7. 트랜잭션을 로그로 남긴다.
  
  5.4 단계 1: 클라이언트 커넥션 수락
  
  5.41 새 커넥션 다루기
  클라이언트가 웹 서버에 tcp 커넥션을 요청하면, 웹 서버는 그 커넥션을 맺고 tcp 커넥션에서 ip 주소를
  추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인 한다.(tcp 커넥션을 조작하는 인터페이스와 자료구조는 운영체제마다 다르다.)
  
  일단 새 커넥션이 맺어지고 받아들여지면, 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다.
  
  5.42 클라이언트 호스트 명 식별
  대부분의 웹 서버는 역방향 DNS 를 사용해서 클라이언트의 ip 주소를 클라이언트의 호스트 명으로 변환하도록 설정되어 있다.
  호스트 명 룩업은 꽤 시간이 많이 걸릴 수 있어 웹 트랜잭션을 느려지게 할 수 있다.
  
  5.43 ident를 통해 클라이언트 사용자 알아내기
  ident 프로토콜은 서버에게 어떤 사용자 이름이 http 커넥션을 초기화했는지 찾아낼 수 있게 해준다.
  이 정보는 특히 웹 서버 로깅에서 유용하기 때문에, 널리 쓰이는 일반 로그 포맷의 두 번째 필드는 각 http 요청의 ident 사용자 이름을 담고 있다.
  
  공공 인터넷에서 ident를 잘 사용하지 않는 이유
  p 133 참고
  
  5.5 단계 2 요청 메세지 수신
  요청 매사자 파싱 시 웹 서버가 하는일
  p 134 참고
  
  5.51메시지의 내부 표현
  몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.
  
  5.52 커넥션 입력/출력 처리 아키텍쳐
  고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다.
  웹 서버들은 항상 새 요청을 주시하고 있다. 왜냐하면 요청은 언제라도
  도착할 수 있기 때문이다.
  
  단일 스레드 웹 서버 : 이는 한 번에 하나씩 요청을 처리한다.
  이 아케텍처는 구현하기 간단하지만 처리 도중에 모든 다른 커넥션은 무시한다.
  
  멀티프로세스와 멀티스레드 웹서버 : 여러 요청을 동시에 처리하기 위해 여러 개 의 프로세스 혹은 고효율 스레드를 할당한다.
  몇몇 서버는 매 커넥션마다 스레드.프로세스 하나를 할당하지만, 서버가 많아지면 동시 커넥션을 처리할 떄
  그로 인해 만들어진 수많은 프로세스나 스레드는 너무 많은 메모리나 시스템 리소스를 소비하게 된다.
  때문에 많은 멀티스레드 웹서비스가 스레드/프로세스의 최대 개수에 제한을 건다.
  
  다중 i/o 서버 : 모든 커넥션은 동시에 그 활동을 감시당한다. 커넥션의 상태가 바뀌면, 그 커넥션에 대한
  작은 양의 처리가 수행된다. 그 처리가 완료되면, 커넥션은 다음번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다.
  어떤 커넥션에 대한 작업을 수행하는 것은 그 커넥션에 실제로 해야 할 일이 있을 때뿐이다.
  스레드와 프로세스는 유휴 상태의 커넥션에 매여 기다리느라 리소스를 낭비하지 않는다.
  
  다중 멀티스레드 웹서버: 몇몇 시스템은 자신의 컴퓨터 플랫폼에 올라와 있는 CPU 여러 개의 이점을 살리기 위해
  멀티스레딩과 다중화를 결합한다.
  여러 개의 스레드는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다.
  
  //////p136 까지
  
  ////2020  - 10 - 28
  
  5.6 요청 처리
  웹 서버가 요청을 받으면, 서버는 요청으로부터 메서드, 리소스, 헤더, 본문을 얻어내어 처리한다.
  
  5.7 리소스의 매핑과 접근
  웹 서버는 리소스 서버다. 그들은 html 페이지나 jpeg이미지 같은 미리 만들어진 콘텐츠를 제공하며,
  마찬가지로 서버 위에서 동작하는 리소스 생성 애플리케이션을 통해 만들어진 동적 콘텐츠도 제공한다.
  웹 서버가 클라이언트에 콘텐츠를 전달하려면, 그전에 요청 메세지의 url에 대응하는 알맞은 콘텐츠나
  콘텐츠 생성기를 웹 서버에서 찾아서 그 콘텐츠의 원천을 식별해야 한다.
  
  5.71 docroot
  웹 서버는 여러 종류의 리소스 매핑을 지원한다. 리소스 매핑의 가장 단순한 형태는
  요청 url를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것이다.
  일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해둔다.
  이 폴더는 문서 루트 혹은 docroot라 불린다.
  
  가상 호스팅된 docroot : 가상 호스팅 웹 서버는, 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로
  한 웹 서버에서 여러 개의 웹 사이트를 호스팅 한다. 가상 호스팅 웹 서버는 url 이나 host 헤더에서 얻은
  ip 주소나 호스트 명을 이용해 올바른 문서 루트를 식별한다.
  이 방법으로 하나의 웹 서버 위에서 두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 할 수 있다.
  아파치 웹 서버에서는 각 가상 웹 사이트의 virtualhost 블록이 가상 서버의 대한 documentroot 지시자를 포함하도록 설정해야 한다.
  
  사용자 홈 디렉터리 docroots : 사용자들이 한 대의 웹 서버에서 각자의 개인 웹사이트를 만들 수 있도록 해주는 것이다.
  보통 빗금/ 과 물결표~ 다음에 사용자 이름이 오는 것으로 시작한다.
  
  5.72 디렉터리 목록
  웹 서버는 경로가 파일이 아닌 디렉터리를 가리키는 디렉터리 url에 대한 요청을 받을 수 있다.
  웹 서버가 취하는 행동은 아래의 3가지이다.
  1. 에러를 반환한다.
  2. 디렉터리 대신 특별한 색인 파일을 반환한다.
  3. 디렉터리를 탐색해서 그 내용을 담은 html 페이지를 반환한다.
  대부분의 웹 서버는 요청한 url 에 대응되는 디렉터리 안에서 index.html 혹은
  index.htm 으로 이름 붙은 파일을 찾는다.
  
  5.73 동적 콘텐츠 리소스 매핑
  웹 서버들 중에서 애플리케이션 서버라고 불리는 것들은 웹 서버를 복잡한 백엔드 애플리케이션과 연결 하는 일을 한다.
  
  5.74 서버사이드 인클루드 ssi
  만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를
  클라이언트에게 보내기 전에 처리한다.
  
  5.75 접근제어
  
  5.8 응답 만들기
  
  5.81 응답 엔터티
  응답 메시지는 다음을 포함한다.
  1. 응답 본문의 mime 타입을 서술하는 content-type 헤더
  2. 응답 분문의 길이를 서술하는 content-length 헤더
  3. 실제 응답 분문의 내용
  
  5.82 mime 타입 결정하기
  매직 타이핑 magic typing : 아파지 웹 서버는 각 파일의 mime 타입을 알아내기 위해 파일의
  내용을 검사해서 알려진 패턴에 대한 테이블에 해당하는 패턴이 있는지 찾아 볼 수 있다.
  이 방법은 느리긴 하지만 파일이 표준 확장자 없이 이름 지어진 경우에는 특히 편리하다.
  
  유형 명시 explicit typing : 특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이
  어떤 mime 타입을 갖도록 웹 서버를 설정할 수 있다.
  
  유형 협상 type negotiation: 한 리소스가 여러 종류의 문서 형식에
  속하도록 설정할 수 있는 웹서버이며, 이때 웹 서버가 사용자와의 협상 과정을 통해 사용하기 좋은
  형식을 판별한 것인지의 여부도 설정할 수 있다.
  
  5.83 리다이렉션
  웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.
  location 응답 헤더는 콘텐츠의 새로운 혹은 선호하는 위치에 대한 url을 포함한다.
  리다이렉트는 다음의 경우에 해당한다.
  
  영구히 리소스가 옮겨진 경우 / 임시로 리소스가 옮겨진 경우 / url 증강 / 부하 균형 / 친밀한 다른 서버가 있을때 / 디렉터리 이름 정규화
  p 144 ~145 참고
  
  5.9 응답 보내기
  서버는 커넥션 상태를 추적해야 하며,지속적인 커넥션은 특히 주의해서 다룰 필요가 있다.
  비지속적 커넥션이라면, 서버는 모든 메시지를 전송했을 때 자신쪽의 커넥션을 닫을 것이다.
  
  5.10 로깅
  트랜잭션이 완료 되면, 웹서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다.
  
  ////////////////////p146 까지 함
  
  
