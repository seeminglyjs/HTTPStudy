http는 HTML에서 확인할 수 있는 request 와 response를 나타낸다.


////2020  - 10 - 20

웹 서버는 http 프로토콜로 의사소통 하기 때문에 http 서버라고도 불린다.
클라이언트가 서버에 http를 요청하고 이에 대하여 서버가 http로 응답하는 과정을 거친다.

어떤 종류의 컨텐츠 소스도 리소스가 될 수 있다

http 는 웹에서 전송되는 객체 각각에 신중하게 mime 타입이라는 데이터 포맥 라벨을 붙이다.
mime는 / 사선으로 구분되면 앞에는 주타임 뒤에는 부타입을 나타낸다.ex) Content-type : image/jpeg

uri(uniform resource identifier) : 정보리소스를 고유하게 식별하고 위치를 지정할 수있다. 
클라이언트가 선택하는 관심있는 리소스

url(uniform resource locator) : 리소스 식별자의 가장 흔한 형태다.
이는 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.
구서 요소로는 스킴(http://) + 주소 + 웹서버의 리소스

※ url 과 uri 가 같은 의미로 사용되기도 한다.

http 는 여러 종류의 method가 있는데 그 중에서 가장 많이 사용되는 것은
(GET, PUT DELETE, POST, HEAD)등이 있다. 차후 자세히....

http 상태코드 200(좋다), 302(다시 보내라), 404(오류)

http이 메세지 구성은 시작줄 / 헤더 / 본문 으로 이루어져 있다.
이 중 헤더는  :쌍점으로 구분되며, 빈줄로 끝난다.
http / 1.0 200 OK (시작줄)
Content-type : text/plain(헤더)
Content-length 19

Hello World!(본문)

//////// p 13 까지 공부

////2020  - 10 - 21

  TCP/IP는 TCP/IP가 층을 이루는 패킷교환 네트워크 프로토콜의 집합이다.
  일단 TCP 커넥션이 맺어지면 클라이언트와 서버 컴퓨터간에 교환되는
  메세지가 없어지거나 손상되거나 순서가 뒤바뀌어 수신되는 일은 결코 없다.
  IP < TCP < HTTP(상위계층)
  
  HTTP의 서버의 IP주소와 포트번호는 URL을 이용해 손쉽게 알아넬 수 있다.
  
  호스트 명은 IP주소에 대한 이해하기 쉬운 형태의 별명인데, 호스트 명은
  도메인 이름 서비스 DNS 라 불리는 장치를 통해 쉽게 IP로 변환될  수 있다.
  
  텔넷 유틸리티는 당신의 키보드를 목적지의 TCP포토로 연결해주고 출력 TCP포트를
  당신의 화면에 연결해 준다.
  
  ////웹의 구성요소 //////
  
  프락시 : 클라이언트와 서버사이에 위치하여, 클라이언트의 모든 HTTP요청을 받아
  서버에 전달한다. 주로 보안을 위해 사용되며, 요청과 응답을 필터링한다.
  
  캐시: 웹캐시와 캐시 프락시는 자신을 거쳐가는 문서들 중 자주 찾는 것의 사본을 
  저장 해 두는, 특별한 종류의 HTTP 프락시 서버이다.
  
  게이트웨이: HTTP트래픽을 다른 프로토콜로 변환하기 위해 사용한다.
  
  터널: 두 커넥션 사이에서 날 데이터를 열어보지 않고 그대로 전달해주는
  HTTP 어플리케이션이다.

////////////////////2장 URL과 리소스//////////////////////////

  URL은 부라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며, URL을 이용해 
  사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며, 공유할 수 있다.
  대부분의 URL은 스킴://서버위치/경로 로 구성되어 있다.
  
  URL 스킬의 문법은 일반적으로 9개로 나누어지며, 중요한 세가지는
  컴포넌트는 스킴, 호스트, 경로 이다.
  
  <스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프레그먼트>
  자세한 내용은 p 31 쪽~~ 참고
  
  질의 문자열은 보통 리소스에 해당 자원이 있는지에 대하여 확인을 하기 위해 사용한다.
  제외된 특정 문자를 제외하고 편의상 &을 이용해 이름 = 값 쌍 형식의 질의 문자열을 많이 사용한다.
  
  프래그먼트는 리소스안에 특정 절을 가리킬 수 있는 컨포넌트로써 # 뒤에 해당 프레그먼트를 넣으면
  웹사이트상에 스크롤이 해당 리소스로 이동하게 된다.

  p 35 까지 공부
  
////2020  - 10 - 22

  2.31
  url은 상대 url과 절대 url 두가지로 나늰다. 절대 url은 리소스에 접근하는데 필요한 모든 정보를 가지고 있다.
  그와달리 상대 url은 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는 기저(base)라고 하는 다른 url 을 사용해야 한다.
  상대 url은 url을 짧게 표기하는 방식이다.
  상대 url은 프래그먼트이거나 url 일부다. url을 처리하는 브라우저 같은 애플리케이션은 상대 url과 절대 url간에
  상호 변환을 할 수 있어야 한다.
  
  url의 변환 괒어은 p 38 ~ 39 쪽을 참고하자!
  
  2.32
  어떤 부라우저들은 url을 입력한 다음이나 입력하고 있는 동안에 자동으로 url을 확장한다.
  이 확장 기능은 두가지로 나누어 진다.
  1. 호스트명 확장 : 이 기능을 지원하는 브라우저는 단순한 휴리스틱스만을 사용해서 입력한 호스트명을
  전체 호스트 명으로 확장할 수 있다.  
  2. 히스토리 확장: 사용자가 url을 입력하는 시간을 줄이고자, 브라우저가 사용하는 또 다른 기술은 과거에
  사용자가 방문했던 url의 기록을 저장해 놓은 것이다. (cookie)를 말하는 듯 싶다...
  
  2.4 안전하지 않은 문자.
  url은 잘 호환되도록 설계되었다. 안전한 전송이란 정보가 유실될 위험 없이 url을 전송할 수 있다는 것을 의미한다.
  하지만 url은 더 완벽해져야 했다. url 설계자는 사람들이 url에 이진 데이터나 일반적으로 안전한 알파벳 외의 문자도
  포함하려고 할 때가 있다는 것을 알게 되었다. 그래서 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한
  문자로 인코딩할 수 있게 하였다.
  
  2.41
  컴퓨터 시스템의 기본문자는 영어중심으로 설정되어 있다. (US-ASCII) 때문에 사용가능한 문자들이 한정적
  대안으로 이스케이프 기능을 통해 US-ASCII에서 사용이 금지된 문자들도 특정문자나
  데이터를 인코딩 할 수 있게 함으로써 이동성과 완성도를 높였다.
  
  2.42 인코딩 체계
  인코딩은 안전하지 않은 문자를 퍼센티지 기호(%)로 시작해 ASCII 코드로 표현되는 두 개의 16 진수 숫자로 이루어진
  이스케이프 문자로 바꾼다.
  P 42 쪽을 참고하자.
  
  2.43 문자제한
  몇몇 문자는 url 내에서 특별한 의미로 예약이 되어 있다.
  어떤 문자는 US-ASCII의 출력 가능한 문자 집합에 포함되어 있지 않다.
  그리고 어떤 문자는 몇몇 인터넷 게이트웨이와 프로토콜에서 혼동되는 것으로 알려져 있어 사용이 꺼려졌다.
  구체적인 제한 문자들은 P 42 쪽을 참고하자.
  
  2.44
  
  2.5 스킴의 바다
  
  HTTP ==  http://<호스트>:<포트>/<경로>?<질의>#<프레그먼트>
  기본포트 : 80
  
  HTTPS == http://<호스트>:<포트>/<경로>?<질의>#<프레그먼트>
  기본포트 : 443
  기본적인 구성은  http와 같지만 넷스케이프에서 개발한 보안 소켓 계층 SSL을 사용한다는 것이다.
  
  나머지 MAILTO / FTP / RTSP,RTSPU / FILE / NEWS / TELNET 는 P 45쪽을 참고하자.
  
  2.6 ~ 2.7
  P 46 ~ 47 기타 참조 내용들
  


////2020  - 10 - 23

제 3장 http 메시지

  3.1 메시지의 흐름  
  HTTP 메시지는 HTPP 애플리케이션 간에 주고받은 데이터의 블록들이다.
  
  3.11 메시지는 원 서버 방향을 인바운드로 햐여 송신된다. 
  메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은
  아웃바운드로 이동하는 것이다.
  
  3.12 다운스트림으로 흐르는 메시지
  HTTP 메시지는 강물과 같이 흐르며, 요청메시지냐 응답 메시지냐에 관계없이 모든 메시지는
  다운스트림으로 흐른다. (위에서 아래로 → 보내는 쪽이 위 받는 쪽이 아래라는 의미)
  
  3.2 메세지의 각 부분
  메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.
  시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다.
  시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.
  이 줄바꿈 문자열을 CRLF라고 쓴다.
  
  3.21메시지 문법
  모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.
  
  요청 메시지 형식: <메세지> <요청URL> <버전>
                  <헤더>
                  
                  <엔티티 분문>
                  
  응답 메시지 형식: <버전> <상태 코드> <사유 구절>
                  <헤더>
                  
                  <엔티티 분문>
 
 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
 상태코드 : 요청 중에 무엇이 일어났는지 설명하는 세자리의 숫자다.
 사유 구절 : 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
 
 3.22 시작줄
 모든 HTTP 메시지는 시작줄로 시작한다.
 요청줄: 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
 응답줄: 숭행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
 
 메서드: GET/HEAD/POST/PUT/TRACE/OPTIONS/DELETE
 자세한 내용은 P55쪽을 참조하자.
 
 상태코드: 클라이언트에게 무엇이 일어났는지 말해준다.
 100 - 199 정보
 200 - 299 성공
 300 - 399 리다이렉션
 400 - 499 클라이언트 에러
 500 - 599 서버 에러
 
 200 OK  요청한 모든 데이터는 응답 본문에 들어있다.
 401 UNAUTHORIZED 사용자 이름과 비밀번호를 입력해야 한다.
 404 NOT FOUND 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다.
 
 사유구절: 상태 코드에 대한 글로 설명을 제공한다.
 버전 번호: HTPP/X.Y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
  버전 번호는 분수로 다루어 지지 않음에 주의하라 3.22 가 3.3보다 큰 수이다.
  이는 버전의 각 숫자는 분리된 숫자로 다루어지기 때문이다.
 
 3.23 헤더
 HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적으로
 이름/값 쌍의 목록이다.
 P58~59 참조
 
 헤더를 여러 줄로 나누기: 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭문자가 와야 한다.
 
 3.24엔티티본문
 
 3.25 버전 0.9 메시지
 
 3.3 메서드
 
 3.31 안전한 메서드(SAFE METHOD)
 GET / HEAD 메서드는 아전하다고 볼 수 있는데 이는 메서드를 사용하는
 HTTP의 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
 안전 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은
 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP애플리케이션을 만들 수 있도록 하는 것이다.
 EX) 송금이 된다. 등의 경고 메시지가 나타나게 하는 것
 
 3.32GET
 가장 흔희 쓰이는 메서드 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.
 
 3.33HEAD
 GET처럼 해동하지만 서버는 응답으로 헤더만을 돌려준다.
 P62참조
 
 3.34PUT
 PUT을 이용해 웹페이지를 만들고 웹서버에 직접 계시할 수도 있다.
 PUT메서드의 의미는 서버가 요청의 본문을 가지고 요청URL의 이름대로 새 문서를
 만들거나, 이미 URL이 존재한다면, 본문을 사용해서 교체하는 것이다.
 
 3.35POST
 POST 메서드는 서버에 입력데이터를 전송하기 위해 설계되었다. 
 ※POST는 서버에 데이터를 보내기 위해 사용되며,
 ※PUT는 서버에 잇는 리소스에 데이터를 입력하기 위해 사용한다.
 
 3.36TRACE
 TRACE메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
 TRACE 요청은 목적지 서버에서 LOOPBACK 진단을 시작한다.
 
 3.37OPTIONS
 OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
 
 3.38DELETE
 서버에게 요청 URL로 지정한 리소스를 사제할 것을 요청한다.
 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 이는
 HTTP명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.
 
 3.39 확장 메서드
 P66참조
 
 3.4 상태 코드 
 3.41 ~ 3.45
 P67 ~76 참조
 
 3.5 헤더
 헤더는 일반헤더/요청헤더/응답헤더/엔티티헤더/확장헤더/로 나누어진다.(보통)
 
 3.51 일반헤더
 메시지의 아주 기본적인 정보를 제공한다.
 
 3.52요청헤더
 요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나
 클라이언트의 선호나 능력에 대한 정보를 준다.
 P79참조
 ACCEPT 관련 헤더
 P79참조
 조건부 요청 헤더 / 요청 보안 헤더
 P80참조
 
/////////// P80 까지 공부함
 
 

////2020  - 10 - 24

프락시 요청 헤더
p.81참조

3.53 응답 헤더
응답 메시지는 그들만의 헤더를 갖는다. 응답 헤더는 클라이언트에게 부가 정보를 제공한다.
응답에 대한 특별한 설명도 제공할 수 있다.

협상 헤더 / 응갑 보안 헤더 

3.54 엔터티 헤더
콘텐츠 헤더 / 엔터티 캐싱 헤더
p.83 참조

////////4장 커넥션 관리 ////////

4.1 TCP 커넥션
전세계 모든 HTTP 통신은, 패킷 교환 네트워크 프로토콜들의 계층화된 집합인
TCP/IP를 통해 이루어진다.
일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은
손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

4.11 신뢰할 수 있는 데이터 통로 TCP

4.12 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
TCP 는 IP 패킷 이라고 불리는 작은 조각을 통해 데이터를 전송한다.
HTTP 는  IP TCP HTTP 로 구성된 프로토콜 스택에서 가장 최상위 계층이다.
HTTP에 보안 기능을 더한 HTTPS 는 TLS 혹은  SSL 이라 불리기도 하며,
HTTP TCP 사이에 있는 암호화 계층이다.

4.13 TCP 커넥션 유지하기
IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 어플리케이션으로 연결된다.
TCP 커넥션은 네 가지 값으로 식별한다.
<발신지 IP 주소, 발신지 포트, 수신지IP주소, 수신지 포트>
어떤 커넥션들은 같은 목적지 포트 번호를 가리킬 수도 있고, 같은 발신지 IP 주소를 
가르키는 커넥션들도 존재할 수 있지만 네 가지 커넥션 구성요소를 모두 똑같이
가르키고 있는 커넥션을 있을 수 없다.

4.14 TCP 소켓 프로그래밍
P.90 참조
소캣 API를 사용하면  TCP 종단 데이터 구조를 생성하고,원격 서버의 TCP 종단에
그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

4.2 TCP의 성능에 대한 고려
P 91 ~ P 98 참조

4.3 HTTP 커넥션 관리

4.31 흔히 잘못 이해하는 CONNECTION 헤더
CONNECTION 헤더는 토큰이 전달되는 3가지 방법이있다.(혼동되는)
HTTP 헤더 필드명은 이 커넥션에만 해당되는 헤더들을 나열한다.
임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미한다.
CLOSE 값은 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.

CONNECTION 헤더는 홉별 헤더명을 기술하는데, 이를 헤더 보호화기라고 한다.
HOP 은 각 서버를 의미하며, 홉별은 특정 두 서버 간에만 영향을 미치고 다른 서버 간에는
영향을 미치지 않음을 의미한다.

4.32 순차적인 트랜잭션 처리에 의한 지연
병렬 커넥션 / 지속 커넥션 / 파이프라인 커넥션 / 다중 커넥션

4.4병렬 커넥션
HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을
병렬로 처리할 수 있게 한다.

4.41 병렬 커넥션은 페이지를 더 빠르게 내려받는다.
각 커넥션의 지연시간을 겹치게 하면 총 지연 시간을 줄일 수 있고,
클라이언트의 인터넷 대역폭을 한 개의 커넥션의 다 써버리는 것이 아니라면
나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.

4.42 병렬 커넥션이 항상 더 빠르지는 않다.
네트워크의 대역폭이 좁을 때 대부분 시간을 데이터를 전송하는데 만 쓴다.
브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은수 대부분 6 ~8개의
병력 커넥션만 허용한다.

4.43 병력 커넥션은 더 빠르게 느껴질 수 있다.
화면에 여러 개의 객체를 동시에 보이면서 내려받고 있는 상황을 볼 수 있기
때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 것이다.

///P 103 까지 



